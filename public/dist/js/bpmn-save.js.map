{"version":3,"file":"bpmn-save.js","sources":["../../node_modules/@maxgraph/core/lib/esm/util/MaxXmlRequest.js","../../node_modules/@maxgraph/core/lib/esm/util/requestUtils.js","../../node_modules/@maxgraph/core/lib/esm/serialization/ObjectCodec.js","../../node_modules/@maxgraph/core/lib/esm/serialization/CodecRegistry.js","../../node_modules/@maxgraph/core/lib/esm/serialization/Codec.js","../../node_modules/@maxgraph/core/lib/esm/serialization/codecs/CellCodec.js","../../node_modules/@maxgraph/core/lib/esm/serialization/codecs/ModelCodec.js","../../node_modules/@maxgraph/core/lib/esm/serialization/codecs/mxGraph/utils.js","../../node_modules/@maxgraph/core/lib/esm/serialization/codecs/mxGraph/mxCellCodec.js","../../node_modules/@maxgraph/core/lib/esm/serialization/codecs/mxGraph/mxGeometryCodec.js","../../node_modules/@maxgraph/core/lib/esm/serialization/register-shared.js","../../node_modules/@maxgraph/core/lib/esm/serialization/register-model-codecs.js","../../node_modules/@maxgraph/core/lib/esm/serialization/ModelXmlSerializer.js","../../resources/ts/bpmn-save.ts"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2020, JGraph Ltd\nCopyright (c) 2006-2020, draw.io AG\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { write } from './domUtils.js';\n/**\n * This class provides a cross-browser abstraction for Ajax requests. It is an XML HTTP request wrapper.\n *\n * See also {@link get}, {@link getAll}, {@link post} and {@link load}.\n *\n * ### Encoding\n *\n * For encoding parameter values, the built-in encodeURIComponent JavaScript\n * method must be used. For automatic encoding of post data in {@link Editor} the\n * {@link Editor.escapePostData} switch can be set to true (default). The encoding\n * will be carried out using the conte type of the page. That is, the page\n * containing the editor should contain a meta tag in the header, e.g.\n * ```html\n * <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n * ```\n *\n * @example\n * ```js\n * const onload = function(req) {\n *   window.alert(req.getDocumentElement());\n * }\n *\n * const onerror = function(req) {\n *   window.alert('Error');\n * }\n * new MaxXmlRequest(url, 'key=value').send(onload, onerror);\n * ```\n *\n * ### Sending requests\n *\n * Sends an asynchronous POST request to the specified URL.\n *\n * @example\n * ```js\n * const req = new MaxXmlRequest(url, 'key=value', 'POST', false);\n * req.send();\n * window.alert(req.getDocumentElement());\n * ```\n *\n * Sends a synchronous POST request to the specified URL.\n *\n * @example\n * ```js\n * const encoder = new Codec();\n * const result = encoder.encode(graph.getDataModel());\n * const xml = encodeURIComponent(xmlUtils.getXml(result));\n * new MaxXmlRequest(url, `xml=${xml}`).send();\n * ```\n *\n * Sends an encoded graph model to the specified URL using xml as the\n * parameter name. The parameter can then be retrieved in C# as follows:\n *\n * ```csharp\n * string xml = HttpUtility.UrlDecode(context.Request.Params[\"xml\"]);\n * ```\n *\n * Or in Java as follows:\n *\n * ```java\n * String xml = URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\");\n * ```\n *\n * Note that the linefeed should only be replaced if the XML is processed in Java, for example when creating an image.\n */\nexport default class MaxXmlRequest {\n    constructor(url, params = null, method = 'POST', async = true, username = null, password = null) {\n        /**\n         * Boolean indicating if the request is binary. This option is ignored in IE.\n         * In all other browsers the requested mime type is set to\n         * text/plain; charset=x-user-defined. Default is false.\n         *\n         * @default false\n         */\n        this.binary = false;\n        /**\n         * Specifies if withCredentials should be used in HTML5-compliant browsers. Default is false.\n         *\n         * @default false\n         */\n        this.withCredentials = false;\n        /**\n         * Holds the inner, browser-specific request object.\n         */\n        this.request = null;\n        /**\n         * Specifies if request values should be decoded as URIs before setting the\n         * textarea value in {@link simulate}. Defaults to false for backwards compatibility,\n         * to avoid another decode on the server this should be set to true.\n         */\n        this.decodeSimulateValues = false;\n        this.url = url;\n        this.params = params;\n        this.method = method || 'POST';\n        this.async = async;\n        this.username = username;\n        this.password = password;\n    }\n    /**\n     * Returns {@link binary}.\n     */\n    isBinary() {\n        return this.binary;\n    }\n    /**\n     * Sets {@link binary}.\n     *\n     * @param value\n     */\n    setBinary(value) {\n        this.binary = value;\n    }\n    /**\n     * Returns the response as a string.\n     */\n    getText() {\n        return this.request.responseText;\n    }\n    /**\n     * Returns true if the response is ready.\n     */\n    isReady() {\n        return this.request.readyState === 4;\n    }\n    /**\n     * Returns the document element of the response XML document.\n     */\n    getDocumentElement() {\n        const doc = this.getXml();\n        if (doc != null) {\n            return doc.documentElement;\n        }\n        return null;\n    }\n    /**\n     * Returns the response as an XML document. Use {@link getDocumentElement} to get\n     * the document element of the XML document.\n     */\n    getXml() {\n        let xml = this.request.responseXML;\n        // Handles missing response headers in IE, the first condition handles\n        // the case where responseXML is there, but using its nodes leads to\n        // type errors in the CellCodec when putting the nodes into a new\n        // document. This happens in IE9 standards mode and with XML user\n        // objects only, as they are used directly as values in cells.\n        if (xml == null || xml.documentElement == null) {\n            xml = new DOMParser().parseFromString(this.request.responseText, 'text/xml');\n        }\n        return xml;\n    }\n    /**\n     * Returns the status as a number, e.g. 404 for \"Not found\" or 200 for \"OK\".\n     * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be caught.\n     */\n    getStatus() {\n        return this.request?.status;\n    }\n    /**\n     * Creates and returns the inner {@link request} object.\n     */\n    create() {\n        const req = new XMLHttpRequest();\n        // TODO: Check for overrideMimeType required here?\n        if (this.isBinary() && req.overrideMimeType) {\n            req.overrideMimeType('text/plain; charset=x-user-defined');\n        }\n        return req;\n    }\n    /**\n     * Send the {@link request} to the target URL using the specified functions to process the response asynchronously.\n     *\n     * Note: Due to technical limitations, `onerror` is currently ignored.\n     *\n     * @param onload Function to be invoked if a successful response was received.\n     * @param onerror Function to be called on any error. Unused in this implementation, intended for overridden function.\n     * @param timeout Optional timeout in ms before calling ontimeout.\n     * @param ontimeout Optional function to execute on timeout.\n     */\n    send(onload = null, onerror = null, timeout = null, ontimeout = null) {\n        this.request = this.create();\n        if (this.request != null) {\n            if (onload != null) {\n                this.request.onreadystatechange = () => {\n                    if (this.isReady()) {\n                        onload(this);\n                        this.request.onreadystatechange = null;\n                    }\n                };\n            }\n            this.request.open(this.method, this.url, this.async, this.username, this.password);\n            this.setRequestHeaders(this.request, this.params);\n            if (window.XMLHttpRequest && this.withCredentials) {\n                this.request.withCredentials = 'true';\n            }\n            if (window.XMLHttpRequest && timeout != null && ontimeout != null) {\n                this.request.timeout = timeout;\n                this.request.ontimeout = ontimeout;\n            }\n            this.request.send(this.params);\n        }\n    }\n    /**\n     * Sets the headers for the given request and parameters. This sets the\n     * content-type to application/x-www-form-urlencoded if any params exist.\n     *\n     * @example\n     * ```JavaScript\n     * request.setRequestHeaders = function(request, params)\n     * {\n     *   if (params != null)\n     *   {\n     *     request.setRequestHeader('Content-Type',\n     *             'multipart/form-data');\n     *     request.setRequestHeader('Content-Length',\n     *             params.length);\n     *   }\n     * };\n     * ```\n     *\n     * Use the code above before calling {@link send} if you require a\n     * multipart/form-data request.\n     *\n     * @param request\n     * @param params\n     */\n    setRequestHeaders(request, params) {\n        if (params != null) {\n            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        }\n    }\n    /**\n     * Creates and posts a request to the given target URL using a dynamically\n     * created form inside the given document.\n     *\n     * @param doc Document that contains the form element.\n     * @param target Target to send the form result to.\n     */\n    simulate(doc, target = null) {\n        doc = doc || document;\n        let old = null;\n        if (doc === document) {\n            old = window.onbeforeunload;\n            window.onbeforeunload = null;\n        }\n        const form = doc.createElement('form');\n        form.setAttribute('method', this.method);\n        form.setAttribute('action', this.url);\n        if (target != null) {\n            form.setAttribute('target', target);\n        }\n        form.style.display = 'none';\n        form.style.visibility = 'hidden';\n        const params = this.params;\n        const pars = params.indexOf('&') > 0 ? params.split('&') : params.split(' ');\n        // Adds the parameters as text areas to the form\n        for (let i = 0; i < pars.length; i += 1) {\n            const pos = pars[i].indexOf('=');\n            if (pos > 0) {\n                const name = pars[i].substring(0, pos);\n                let value = pars[i].substring(pos + 1);\n                if (this.decodeSimulateValues) {\n                    value = decodeURIComponent(value);\n                }\n                const textarea = doc.createElement('textarea');\n                textarea.setAttribute('wrap', 'off');\n                textarea.setAttribute('name', name);\n                write(textarea, value);\n                form.appendChild(textarea);\n            }\n        }\n        doc.body.appendChild(form);\n        form.submit();\n        if (form.parentNode != null) {\n            form.parentNode.removeChild(form);\n        }\n        if (old != null) {\n            window.onbeforeunload = old;\n        }\n    }\n}\n","/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2020, JGraph Ltd\nCopyright (c) 2006-2020, draw.io AG\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport MaxXmlRequest from './MaxXmlRequest.js';\n/**\n * Loads the specified URL *synchronously* and returns the {@link MaxXmlRequest}.\n * Throws an exception if the file cannot be loaded.\n * See {@link get} for  an asynchronous implementation.\n *\n * Example:\n *\n * ```javascript\n * try {\n *   const req = load(filename);\n *   cont root = req.getDocumentElement();\n *   // Process XML DOM...\n * } catch (e) {\n *   console.error(`Cannot load $filename`, e);\n * }\n * ```\n *\n * @param url URL to get the data from.\n */\nexport const load = (url) => {\n    const req = new MaxXmlRequest(url, null, 'GET', false);\n    req.send();\n    return req;\n};\n/**\n * Loads the specified URL *asynchronously* and invokes the given functions depending on the request status.\n * Returns the {@link MaxXmlRequest} in use.\n * Both functions take the {@link MaxXmlRequest} as the only parameter.\n * See {@link load} for a synchronous implementation.\n *\n * Example:\n *\n * ```javascript\n * get(url, (req) => {\n *    const node = req.getDocumentElement();\n *    // Process XML DOM...\n * });\n * ```\n *\n * So for example, to load a diagram into an existing graph model, the following code is used.\n *\n * ```javascript\n * get(url, (req) => {\n *   const node = req.getDocumentElement();\n *   const dec = new Codec(node.ownerDocument);\n *   dec.decode(node, graph.getDataModel());\n * });\n * ```\n *\n * @param url URL to get the data from.\n * @param onload Optional function to execute for a successful response.\n * @param onerror Optional function to execute on error.\n * @param binary Optional boolean parameter that specifies if the request is binary.\n * @param timeout Optional timeout in ms before calling ontimeout.\n * @param ontimeout Optional function to execute on timeout.\n * @param headers Optional with headers, eg. {'Authorization': 'token xyz'}\n */\nexport const get = (url, onload = null, onerror = null, binary = false, timeout = null, ontimeout = null, headers = null) => {\n    const req = new MaxXmlRequest(url, null, 'GET');\n    const { setRequestHeaders } = req;\n    if (headers) {\n        req.setRequestHeaders = (request, params) => {\n            setRequestHeaders.apply(this, [request, params]);\n            for (const key in headers) {\n                request.setRequestHeader(key, headers[key]);\n            }\n        };\n    }\n    if (binary != null) {\n        req.setBinary(binary);\n    }\n    req.send(onload, onerror, timeout, ontimeout);\n    return req;\n};\n/**\n * Loads the URLs in the given array *asynchronously* and invokes the given function\n * if all requests returned with a valid 2xx status. The error handler is invoked\n * once on the first error or invalid response.\n *\n * @param urls Array of URLs to be loaded.\n * @param onload Callback with array of {@link MaxXmlRequest}s.\n * @param onerror Optional function to execute on error.\n */\nexport const getAll = (urls, onload, onerror) => {\n    let remain = urls.length;\n    const result = [];\n    let errors = 0;\n    const err = () => {\n        if (errors == 0 && onerror != null) {\n            onerror();\n        }\n        errors++;\n    };\n    for (let i = 0; i < urls.length; i += 1) {\n        ((url, index) => {\n            get(url, (req) => {\n                const status = req.getStatus();\n                if (status < 200 || status > 299) {\n                    err();\n                }\n                else {\n                    result[index] = req;\n                    remain--;\n                    if (remain == 0) {\n                        onload(result);\n                    }\n                }\n            }, err);\n        })(urls[i], i);\n    }\n    if (remain == 0) {\n        onload(result);\n    }\n};\n/**\n * Posts the specified params to the given URL *asynchronously* and invokes the given functions depending on the request status.\n * Returns the {@link MaxXmlRequest} in use.\n * Both functions take the {@link MaxXmlRequest} as the only parameter.\n * Make sure to use encodeURIComponent for the parameter values.\n *\n * Example:\n *\n * ```javascript\n * post(url, 'key=value', (req) => {\n *   alert('Ready: ' + req.isReady() + ' Status: ' + req.getStatus());\n *  // Process req.getDocumentElement() using DOM API if OK...\n * });\n * ```\n *\n * @param url URL to get the data from.\n * @param params Parameters for the post request.\n * @param onload Optional function to execute for a successful response.\n * @param onerror Optional function to execute on error.\n */\nexport const post = (url, params = null, onload, onerror = null) => {\n    return new MaxXmlRequest(url, params).send(onload, onerror);\n};\n/**\n * Submits the given parameters to the specified URL using {@link MaxXmlRequest.simulate} and returns the {@link MaxXmlRequest}.\n * Make sure to use encodeURIComponent for the parameter values.\n *\n * @param url URL to get the data from.\n * @param params Parameters for the form.\n * @param doc Document to create the form in.\n * @param target Target to send the form result to.\n */\nexport const submit = (url, params, doc, target) => {\n    return new MaxXmlRequest(url, params).simulate(doc, target);\n};\n","/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from '../util/ObjectIdentity.js';\nimport { GlobalConfig } from '../util/config.js';\nimport Geometry from '../view/geometry/Geometry.js';\nimport Point from '../view/geometry/Point.js';\nimport { isInteger, isNumeric } from '../util/mathUtils.js';\nimport { getTextContent } from '../util/domUtils.js';\nimport { load } from '../util/requestUtils.js';\nimport { doEval, isElement } from '../internal/utils.js';\nconst geometryNumericAttributes = [\n    '_x',\n    '_y',\n    '_width',\n    '_height',\n];\nconst pointNumericAttributes = ['_x', '_y'];\n/**\n * Generic codec for JavaScript objects that implements a mapping between\n * JavaScript objects and XML nodes that maps each field or element to an\n * attribute or child node, and vice versa.\n *\n * ### Atomic Values\n *\n * Consider the following example.\n *\n * ```javascript\n * const obj = new Object();\n * obj.foo = \"Foo\";\n * obj.bar = \"Bar\";\n * ```\n *\n * This object is encoded into an XML node using the following.\n *\n * ```javascript\n * const enc = new Codec();\n * const node = enc.encode(obj);\n * ```\n *\n * The output of the encoding may be viewed using {@link GlobalConfig.logger} as follows.\n *\n * ```javascript\n * GlobalConfig.logger.show();\n * GlobalConfig.logger.debug(mxUtils.getPrettyXml(node));\n * ```\n *\n * Finally, the result of the encoding looks as follows.\n *\n * ```javascript\n * <Object foo=\"Foo\" bar=\"Bar\"/>\n * ```\n *\n * In the above output, the foo and bar fields have been mapped to attributes\n * with the same names, and the name of the constructor was used for the\n * node name.\n *\n * ### Booleans\n *\n * Since booleans are numbers in JavaScript, all boolean values are encoded\n * into 1 for true and 0 for false. The decoder also accepts the string true\n * and false for boolean values.\n *\n * ### Objects\n *\n * The above scheme is applied to all atomic fields, that is, to all non-object\n * fields of an object. For object fields, a child node is created with a\n * special attribute that contains the field name. This special attribute is\n * called \"as\" and hence, as is a reserved word that should not be used for a\n * field name.\n *\n * Consider the following example where foo is an object and bar is an atomic\n * property of foo.\n *\n * ```javascript\n * const obj = {foo: {bar: \"Bar\"}};\n * ```\n *\n * This will be mapped to the following XML structure by ObjectCodec.\n *\n * ```javascript\n * <Object>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Object>\n * ```\n *\n * In the above output, the inner Object node contains the as-attribute that\n * specifies the field name in the enclosing object. That is, the field foo was\n * mapped to a child node with an as-attribute that has the value foo.\n *\n * ### Arrays\n *\n * Arrays are special objects that are either associative, in which case each\n * key, value pair is treated like a field where the key is the field name, or\n * they are a sequence of atomic values and objects, which is mapped to a\n * sequence of child nodes. For object elements, the above scheme is applied\n * without the use of the special as-attribute for creating each child. For\n * atomic elements, a special add-node is created with the value stored in the\n * value-attribute.\n *\n * For example, the following array contains one atomic value and one object\n * with a field called bar. Furthermore, it contains two associative entries\n * called bar with an atomic value, and foo with an object value.\n *\n * ```javascript\n * const obj = [\"Bar\", {bar: \"Bar\"}];\n * obj[\"bar\"] = \"Bar\";\n * obj[\"foo\"] = {bar: \"Bar\"};\n * ```\n *\n * This array is represented by the following XML nodes.\n *\n * ```javascript\n * <Array bar=\"Bar\">\n *   <add value=\"Bar\"/>\n *   <Object bar=\"Bar\"/>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Array>\n * ```\n *\n * The Array node name is the name of the constructor. The additional\n * as-attribute in the last child contains the key of the associative entry,\n * whereas the second last child is part of the array sequence and does not\n * have an as-attribute.\n *\n * ### References\n *\n * Objects may be represented as child nodes or attributes with ID values,\n * which are used to look up the object in a table within {@link Codec}. The\n * {@link isReference} function is in charge of deciding if a specific field should\n * be encoded as a reference or not. Its default implementation returns true if\n * the field name is in {@link idrefs}, an array of strings that is used to configure\n * the {@link ObjectCodec}.\n *\n * Using this approach, the mapping does not guarantee that the referenced\n * object itself exists in the document. The fields that are encoded as\n * references must be carefully chosen to make sure all referenced objects\n * exist in the document, or may be resolved by some other means if necessary.\n *\n * For example, in the case of the graph model all cells are stored in a tree\n * whose root is referenced by the model's root field. A tree is a structure\n * that is well suited for an XML representation, however, the additional edges\n * in the graph model have a reference to a source and target cell, which are\n * also contained in the tree. To handle this case, the source and target cell\n * of an edge are treated as references, whereas the children are treated as\n * objects. Since all cells are contained in the tree and no edge references a\n * source or target outside the tree, this setup makes sure all referenced\n * objects are contained in the document.\n *\n * In the case of a tree structure we must further avoid infinite recursion by\n * ignoring the parent reference of each child. This is done by returning true\n * in {@link isExcluded}, whose default implementation uses the array of excluded\n * field names passed to the ObjectCodec constructor.\n *\n * References are only used for cells in mxGraph. For defining other\n * referencable object types, the codec must be able to work out the ID of an\n * object. This is done by implementing {@link Codec.reference}. For decoding a\n * reference, the XML node with the respective id-attribute is fetched from the\n * document, decoded, and stored in a lookup table for later reference. For\n * looking up external objects, {@link Codec.lookup} may be implemented.\n *\n * ### Expressions\n *\n * For decoding JavaScript expressions, the add-node may be used with a text\n * content that contains the JavaScript expression. For example, the following\n * creates a field called foo in the enclosing object and assigns it the value\n * of `MyConstant.PROP`.\n *\n * ```javascript\n * <Object>\n *   <add as=\"foo\">MyConstant.PROP</add>\n * </Object>\n * ```\n *\n * The resulting object has a field called foo with the value \"myValue\" (assuming that `MyConstant.PROP=myValue`).\n * Its XML representation looks as follows.\n *\n * ```javascript\n * <Object foo=\"left\"/>\n * ```\n *\n * This means the expression is evaluated at decoding time and the result of\n * the evaluation is stored in the respective field. Valid expressions are all\n * JavaScript expressions, including function definitions, which are mapped to\n * functions on the resulting object.\n *\n * Expressions are only evaluated if {@link allowEval} is true.\n *\n * @category Serialization with Codecs\n */\nclass ObjectCodec {\n    constructor(template, exclude = [], idrefs = [], mapping = {}) {\n        this.template = template;\n        this.exclude = exclude;\n        this.idrefs = idrefs;\n        this.mapping = mapping;\n        this.reverse = {};\n        for (const i in this.mapping) {\n            this.reverse[this.mapping[i]] = i;\n        }\n    }\n    /**\n     * Returns the name used for the node names and lookup of the codec when\n     * classes are encoded and nodes are decoded. For classes to work with\n     * this the codec registry automatically adds an alias for the classname\n     * if that is different from what this returns.\n     *\n     * The default implementation returns the classname of the template class if no name is set.\n     */\n    getName() {\n        return this.name ?? this.template.constructor.name;\n    }\n    setName(name) {\n        this.name = name;\n    }\n    /**\n     * Returns a new instance of the template for this codec.\n     */\n    cloneTemplate() {\n        return new this.template.constructor();\n    }\n    /**\n     * Returns the field name for the given attribute name.\n     * Looks up the value in the {@link reverse} mapping or returns\n     * the input if there is no reverse mapping for the\n     * given name.\n     */\n    getFieldName(attributename) {\n        if (attributename != null) {\n            const mapped = this.reverse[attributename];\n            if (mapped != null) {\n                attributename = mapped;\n            }\n        }\n        return attributename;\n    }\n    /**\n     * Returns the attribute name for the given field name.\n     * Looks up the value in the {@link mapping} or returns\n     * the input if there is no mapping for the\n     * given name.\n     */\n    getAttributeName(fieldname) {\n        if (fieldname != null) {\n            const mapped = this.mapping[fieldname];\n            if (mapped != null) {\n                fieldname = mapped;\n            }\n        }\n        return fieldname;\n    }\n    /**\n     * Returns true if the given attribute is to be ignored by the codec. This\n     * implementation returns true if the given field name is in {@link exclude} or\n     * if the field name equals {@link ObjectIdentity.FIELD_NAME}.\n     *\n     * @param obj Object instance that contains the field.\n     * @param attr Fieldname of the field.\n     * @param value Value of the field.\n     * @param write Boolean indicating if the field is being encoded or decoded.\n     * Write is true if the field is being encoded, else it is being decoded.\n     */\n    isExcluded(obj, attr, value, write) {\n        return attr == ObjectIdentity.FIELD_NAME || this.exclude.indexOf(attr) >= 0;\n    }\n    /**\n     * Returns true if the given field name is to be treated\n     * as a textual reference (ID). This implementation returns\n     * true if the given field name is in {@link idrefs}.\n     *\n     * @param obj Object instance that contains the field.\n     * @param attr Field name of the field.\n     * @param value Value of the field.\n     * @param write Boolean indicating if the field is being encoded or decoded.\n     * Write is true if the field is being encoded, else it is being decoded.\n     */\n    isReference(obj, attr, value, write) {\n        return attr == null ? false : this.idrefs.includes(attr);\n    }\n    /**\n     * Encodes the specified object and returns a node\n     * representing then given object. Calls {@link beforeEncode}\n     * after creating the node and {@link afterEncode} with the\n     * resulting node after processing.\n     *\n     * Enc is a reference to the calling encoder. It is used\n     * to encode complex objects and create references.\n     *\n     * This implementation encodes all variables of an\n     * object according to the following rules:\n     *\n     * - If the variable name is in {@link exclude} then it is ignored.\n     * - If the variable name is in {@link idrefs} then {@link Codec.getId}\n     * is used to replace the object with its ID.\n     * - The variable name is mapped using {@link mapping}.\n     * - If obj is an array and the variable name is numeric\n     * (ie. an index) then it is not encoded.\n     * - If the value is an object, then the codec is used to\n     * create a child node with the variable name encoded into\n     * the \"as\" attribute.\n     * - Else, if {@link encodeDefaults} is true or the value differs\n     * from the template value, then ...\n     * - ... if obj is not an array, then the value is mapped to\n     * an attribute.\n     * - ... else if obj is an array, the value is mapped to an\n     * add child with a value attribute or a text child node,\n     * if the value is a function.\n     *\n     * If no ID exists for a variable in {@link idrefs} or if an object\n     * cannot be encoded, a warning is issued using {@link GlobalConfig.logger}.\n     *\n     * Returns the resulting XML node that represents the given\n     * object.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     */\n    encode(enc, obj) {\n        const node = enc.document.createElement(this.getName());\n        obj = this.beforeEncode(enc, obj, node);\n        this.encodeObject(enc, obj, node);\n        return this.afterEncode(enc, obj, node);\n    }\n    /**\n     * Encodes the value of each member in then given obj into the given node using\n     * {@link encodeValue}.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node that contains the encoded object.\n     */\n    encodeObject(enc, obj, node) {\n        enc.setAttribute(node, 'id', enc.getId(obj));\n        for (const i in obj) {\n            let name = i;\n            const value = obj[name];\n            if (value != null && !this.isExcluded(obj, name, value, true)) {\n                if (isInteger(name)) {\n                    name = null;\n                }\n                this.encodeValue(enc, obj, name, value, node);\n            }\n        }\n    }\n    /**\n     * Converts the given value according to the mappings\n     * and id-refs in this codec and uses {@link writeAttribute}\n     * to write the attribute into the given node.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object whose property is going to be encoded.\n     * @param name XML node that contains the encoded object.\n     * @param value Value of the property to be encoded.\n     * @param node XML node that contains the encoded object.\n     */\n    encodeValue(enc, obj, name, value, node) {\n        if (value != null) {\n            if (this.isReference(obj, name, value, true)) {\n                const tmp = enc.getId(value);\n                if (tmp == null) {\n                    GlobalConfig.logger.warn(`ObjectCodec.encode: No ID for ${this.getName()}.${name}=${value}`);\n                    return; // exit\n                }\n                value = tmp;\n            }\n            // Checks if the value is a default value and the name is correct\n            if (name == null || enc.encodeDefaults || this.template[name] != value) {\n                name = this.getAttributeName(name);\n                this.writeAttribute(enc, obj, name, value, node);\n            }\n        }\n    }\n    /**\n     * Writes the given value into node using {@link writePrimitiveAttribute}\n     * or {@link writeComplexAttribute} depending on the type of the value.\n     */\n    writeAttribute(enc, obj, name, value, node) {\n        if (typeof value !== 'object' /* primitive type */) {\n            this.writePrimitiveAttribute(enc, obj, name, value, node);\n        } /* complex type */\n        else {\n            this.writeComplexAttribute(enc, obj, name, value, node);\n        }\n    }\n    /**\n     * Writes the given value as an attribute of the given node.\n     */\n    writePrimitiveAttribute(enc, obj, name, value, node) {\n        value = this.convertAttributeToXml(enc, obj, name, value, node); // TODO: params don't seem to match - is this a bug? ===================================\n        if (name == null) {\n            const child = enc.document.createElement('add');\n            if (typeof value === 'function') {\n                child.appendChild(enc.document.createTextNode(value));\n            }\n            else {\n                enc.setAttribute(child, 'value', value);\n            }\n            node.appendChild(child);\n        }\n        else if (typeof value !== 'function') {\n            enc.setAttribute(node, name, value);\n        }\n    }\n    /**\n     * Writes the given value as a child node of the given node.\n     */\n    writeComplexAttribute(enc, obj, name, value, node) {\n        const child = enc.encode(value);\n        if (child != null) {\n            if (name != null) {\n                child.setAttribute('as', name);\n            }\n            node.appendChild(child);\n        }\n        else {\n            GlobalConfig.logger.warn(`ObjectCodec.encode: No node for ${this.getName()}.${name}: ${value}`);\n        }\n    }\n    /**\n     * Converts true to \"1\" and false to \"0\" is {@link isBooleanAttribute} returns true.\n     * All other values are not converted.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Objec to convert the attribute for.\n     * @param name Name of the attribute to be converted.\n     * @param value Value to be converted.\n     */\n    convertAttributeToXml(enc, obj, name, value, node) {\n        // Makes sure to encode boolean values as numeric values\n        if (this.isBooleanAttribute(enc, obj, name, value)) {\n            // Checks if the value is true (do not use the value as is, because\n            // this would check if the value is not null, so 0 would be true)\n            value = value == true ? '1' : '0';\n        }\n        return value;\n    }\n    /**\n     * Returns true if the given object attribute is a boolean value.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to convert the attribute for.\n     * @param name Name of the attribute to be converted.\n     * @param value Value of the attribute to be converted.\n     */\n    isBooleanAttribute(enc, obj, name, value) {\n        return typeof value.length === 'undefined' && (value == true || value == false);\n    }\n    /**\n     * Converts booleans and numeric values to the respective types. Values are\n     * numeric if {@link isNumericAttribute} returns true.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be converted.\n     * @param obj Objec to convert the attribute for.\n     */\n    convertAttributeFromXml(dec, attr, obj) {\n        let { value } = attr;\n        if (this.isNumericAttribute(dec, attr, obj)) {\n            value = parseFloat(value);\n            if (Number.isNaN(value) || !Number.isFinite(value)) {\n                value = 0;\n            }\n        }\n        return value;\n    }\n    /**\n     * Returns true if the given XML attribute is or should be a numeric value.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be converted.\n     * @param obj Object to convert the attribute for.\n     */\n    isNumericAttribute(dec, attr, obj) {\n        // Handles known numeric attributes for generic objects\n        return (\n        // There is currently no specific codec for Geometry or Point, so the check is done here\n        (obj instanceof Geometry && geometryNumericAttributes.includes(attr.name)) ||\n            (obj instanceof Point && pointNumericAttributes.includes(attr.name)) ||\n            isNumeric(attr.value));\n    }\n    /**\n     * Hook for subclassers to pre-process the object before\n     * encoding. This returns the input object. The return\n     * value of this function is used in {@link encode} to perform\n     * the default encoding into the given node.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node to encode the object into.\n     */\n    beforeEncode(enc, obj, node) {\n        return obj;\n    }\n    /**\n     * Hook for subclassers to post-process the node\n     * for the given object after encoding and return the\n     * post-processed node. This implementation returns\n     * the input node. The return value of this method\n     * is returned to the encoder from {@link encode}.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node that represents the default encoding.\n     */\n    afterEncode(enc, obj, node) {\n        return node;\n    }\n    /**\n     * Parses the given node into the object or returns a new object\n     * representing the given node.\n     *\n     * Dec is a reference to the calling decoder. It is used to decode\n     * complex objects and resolve references.\n     *\n     * If a node has an id attribute then the object cache is checked for the\n     * object. If the object is not yet in the cache then it is constructed\n     * using the constructor of {@link template} and cached in {@link Codec.objects}.\n     *\n     * This implementation decodes all attributes and childs of a node\n     * according to the following rules:\n     *\n     * - If the variable name is in {@link exclude} or if the attribute name is \"id\"\n     * or \"as\" then it is ignored.\n     * - If the variable name is in {@link idrefs} then {@link Codec.getObject} is used\n     * to replace the reference with an object.\n     * - The variable name is mapped using a reverse {@link mapping}.\n     * - If the value has a child node, then the codec is used to create a\n     * child object with the variable name taken from the \"as\" attribute.\n     * - If the object is an array and the variable name is empty then the\n     * value or child object is appended to the array.\n     * - If an add child has no value or the object is not an array then\n     * the child text content is evaluated using {@link eval}.\n     *\n     * For add nodes where the object is not an array and the variable name\n     * is defined, the default mechanism is used, allowing to override/add\n     * methods as follows:\n     *\n     * ```javascript\n     * <Object>\n     *   <add as=\"hello\"><![CDATA[\n     *     function(arg1) {\n     *       mxUtils.alert('Hello '+arg1);\n     *     }\n     *   ]]></add>\n     * </Object>\n     * ```\n     *\n     * If no object exists for an ID in {@link idrefs} a warning is issued\n     * using {@link GlobalConfig.logger}.\n     *\n     * Returns the resulting object that represents the given XML node\n     * or the object given to the method as the into parameter.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param into Optional object to encode the node into.\n     */\n    decode(dec, node, into) {\n        const id = node.getAttribute('id'); // the subsequent calls work when id is null\n        let obj = dec.objects[id];\n        if (obj == null) {\n            obj = into || this.cloneTemplate();\n            if (id != null) {\n                dec.putObject(id, obj);\n            }\n        }\n        const _node = this.beforeDecode(dec, node, obj);\n        this.decodeNode(dec, _node, obj);\n        return this.afterDecode(dec, _node, obj);\n    }\n    /**\n     * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object to encode the node into.\n     */\n    decodeNode(dec, node, obj) {\n        if (node != null) {\n            this.decodeAttributes(dec, node, obj);\n            this.decodeChildren(dec, node, obj);\n        }\n    }\n    /**\n     * Decodes all attributes of the given node using {@link decodeAttribute}.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object to encode the node into.\n     */\n    decodeAttributes(dec, node, obj) {\n        const attrs = node.attributes;\n        if (attrs != null) {\n            for (let i = 0; i < attrs.length; i += 1) {\n                this.decodeAttribute(dec, attrs[i], obj);\n            }\n        }\n    }\n    /**\n     * Returns true if the given attribute should be ignored. This implementation\n     * returns true if the attribute name is \"as\" or \"id\".\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be decoded.\n     * @param obj Objec to encode the attribute into.\n     */\n    isIgnoredAttribute(dec, attr, obj) {\n        return attr.nodeName === 'as' || attr.nodeName === 'id';\n    }\n    /**\n     * Reads the given attribute into the specified object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be decoded.\n     * @param obj Objec to encode the attribute into.\n     */\n    decodeAttribute(dec, attr, obj) {\n        if (!this.isIgnoredAttribute(dec, attr, obj)) {\n            const name = attr.nodeName;\n            // Converts the string true and false to their boolean values.\n            // This may require an additional check on the obj to see if\n            // the existing field is a boolean value or uninitialized, in\n            // which case we may want to convert true and false to a string.\n            let value = this.convertAttributeFromXml(dec, attr, obj);\n            const fieldname = this.getFieldName(name);\n            if (this.isReference(obj, fieldname, value, false)) {\n                const tmp = dec.getObject(value);\n                if (tmp == null) {\n                    GlobalConfig.logger.warn(`ObjectCodec.decode: No object for ${this.getName()}.${name}=${value}`);\n                    return; // exit\n                }\n                value = tmp;\n            }\n            if (!this.isExcluded(obj, name, value, false)) {\n                obj[name] = value;\n            }\n        }\n    }\n    /**\n     * Decodes all children of the given node using {@link decodeChild}.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeChildren(dec, node, obj) {\n        let child = node.firstChild;\n        while (child) {\n            const tmp = child.nextSibling;\n            if (isElement(child) && !this.processInclude(dec, child, obj)) {\n                this.decodeChild(dec, child, obj);\n            }\n            child = tmp;\n        }\n    }\n    /**\n     * Reads the specified child into the given object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param child XML child element to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeChild(dec, child, obj) {\n        const fieldname = this.getFieldName(child.getAttribute('as'));\n        if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {\n            const template = this.getFieldTemplate(obj, fieldname, child);\n            let value = null;\n            if (child.nodeName === 'add') {\n                value = child.getAttribute('value');\n                if (value == null && ObjectCodec.allowEval) {\n                    value = doEval(getTextContent(child));\n                }\n            }\n            else {\n                value = dec.decode(child, template);\n            }\n            try {\n                this.addObjectValue(obj, fieldname, value, template);\n            }\n            catch (e) {\n                throw new Error(`${e.message} for ${child.nodeName}`);\n            }\n        }\n    }\n    /**\n     * Returns the template instance for the given field. This returns the\n     * value of the field, null if the value is an array or an empty collection\n     * if the value is a collection. The value is then used to populate the\n     * field for a new instance. For strongly typed languages it may be\n     * required to override this to return the correct collection instance\n     * based on the encoded child.\n     */\n    getFieldTemplate(obj, fieldname, child) {\n        let template = obj[fieldname];\n        // Non-empty arrays are replaced completely\n        if (template instanceof Array && template.length > 0) {\n            template = null;\n        }\n        return template;\n    }\n    /**\n     * Sets the decoded child node as a value of the given object. If the\n     * object is a map, then the value is added with the given field name as a\n     * key. If the field name is not empty, then setFieldValue is called or\n     * else, if the object is a collection, the value is added to the\n     * collection. For strongly typed languages it may be required to\n     * override this with the correct code to add an entry to an object.\n     */\n    addObjectValue(obj, fieldname, value, template) {\n        if (value != null && value !== template) {\n            if (fieldname != null && fieldname.length > 0) {\n                obj[fieldname] = value;\n            }\n            else {\n                obj.push?.(value);\n            }\n        }\n    }\n    /**\n     * Returns true if the given node is an include directive and\n     * executes the include by decoding the XML document. Returns\n     * false if the given node is not an include directive.\n     *\n     * @param dec {@link Codec} that controls the encoding/decoding process.\n     * @param node XML node to be checked.\n     * @param into Optional object to pass-thru to the codec.\n     */\n    processInclude(dec, node, into) {\n        if (node.nodeName === 'include') {\n            const name = node.getAttribute('name');\n            if (name != null) {\n                try {\n                    const xml = load(name).getDocumentElement();\n                    if (xml != null) {\n                        dec.decode(xml, into);\n                    }\n                }\n                catch (e) {\n                    // ignore\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Hook for subclassers to pre-process the node for\n     * the specified object and return the node to be\n     * used for further processing by {@link decode}.\n     * The object is created based on the template in the\n     * calling method and is never null. This implementation\n     * returns the input node. The return value of this\n     * function is used in {@link decode} to perform\n     * the default decoding into the given object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object to encode the node into.\n     */\n    beforeDecode(dec, node, obj) {\n        return node;\n    }\n    /**\n     * Hook for subclassers to post-process the object after\n     * decoding. This implementation returns the given object\n     * without any changes. The return value of this method\n     * is returned to the decoder from {@link decode}.\n     *\n     * @param dec {@link Codec} that controls the encoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object that represents the default decoding.\n     */\n    afterDecode(dec, node, obj) {\n        return obj;\n    }\n}\n/**\n * Static global switch that specifies if expressions in arrays are allowed.\n *\n * **WARNING**: Enabling this switch carries a possible security risk.\n *\n * @default false\n */\nObjectCodec.allowEval = false;\nexport default ObjectCodec;\n","/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from './ObjectCodec.js';\n/**\n * Singleton class that acts as a global registry for codecs.\n *\n * ### Adding a Codec\n *\n * 1. Define a default codec with a new instance of the object to be handled.\n *\n *     ```javascript\n *     const codec = new ObjectCodec(new GraphDataModel());\n *     ```\n *\n * 2. Define the functions required for encoding and decoding objects.\n *\n *     ```javascript\n *     codec.encode = function(enc, obj) { ... }\n *     codec.decode = function(dec: Codec, node: Element, into: any): any { ... }\n *     ```\n *\n * 3. Register the codec in the CodecRegistry.\n *\n *     ```javascript\n *     CodecRegistry.register(codec);\n *     ```\n *\n * {@link ObjectCodec.decode} may be used to either create a new instance of an object or to configure an existing instance,\n * in which case the into argument points to the existing object. In this case, we say the codec \"configures\" the object.\n *\n * @category Serialization with Codecs\n */\nclass CodecRegistry {\n    /**\n     * Registers a new codec and associates the name of the codec via {@link ObjectCodec.getName} with the codec object.\n     *\n     * @param codec ObjectCodec to be registered.\n     * @param registerAlias if `true`, register an alias if the codec name doesn't match the name of the constructor of {@link ObjectCodec.template}.\n     */\n    static register(codec, registerAlias = true) {\n        if (codec != null) {\n            const name = codec.getName();\n            CodecRegistry.codecs[name] = codec;\n            const classname = codec.template.constructor.name;\n            if (registerAlias && classname !== name) {\n                CodecRegistry.addAlias(classname, name);\n            }\n        }\n        return codec;\n    }\n    /**\n     * Adds an alias for mapping a class name to a codec name.\n     */\n    static addAlias(className, codecName) {\n        CodecRegistry.aliases[className] = codecName;\n    }\n    /**\n     * Returns a codec that handles objects that are constructed using the given constructor or a codec registered under the provided name.\n     *\n     * When passing a name, the method first check if an alias exists for the name, and if so, it uses it to retrieve the codec.\n     *\n     * If there is no registered Codec, the method tries to register a new Codec using the provided constructor.\n     *\n     * @param constructorOrName JavaScript constructor function of the Codec or Codec name.\n     */\n    static getCodec(constructorOrName) {\n        if (constructorOrName == null) {\n            return null;\n        }\n        let codec = null;\n        // Equivalent of calling import { getFunctionName } from '../util/StringUtils';\n        let name = typeof constructorOrName === 'string' ? constructorOrName : constructorOrName.name;\n        const tmp = CodecRegistry.aliases[name];\n        if (tmp != null) {\n            name = tmp;\n        }\n        codec = CodecRegistry.codecs[name] ?? null;\n        // Registers a new default codec for the given constructor if no codec has been previously defined.\n        if (codec == null) {\n            try {\n                codec = new ObjectCodec(new constructorOrName());\n                CodecRegistry.register(codec);\n            }\n            catch (e) {\n                // ignore\n            }\n        }\n        return codec;\n    }\n    /**\n     * First try to get the codec by the name it is registered with. If it doesn't exist, use the alias eventually declared\n     * to get the codec.\n     * @param name the name of the codec that is willing to be retrieved.\n     */\n    static getCodecByName(name) {\n        let codec = CodecRegistry.codecs[name];\n        if (!codec) {\n            const alias = CodecRegistry.aliases[name];\n            if (alias) {\n                codec = CodecRegistry.codecs[alias];\n            }\n        }\n        return codec ?? null;\n    }\n}\nCodecRegistry.codecs = {};\n/**\n * Maps from classnames to codec names.\n */\nCodecRegistry.aliases = {};\nexport default CodecRegistry;\n","/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellPath from '../view/cell/CellPath.js';\nimport CodecRegistry from './CodecRegistry.js';\nimport Cell from '../view/cell/Cell.js';\nimport { GlobalConfig } from '../util/config.js';\nimport { getFunctionName } from '../util/StringUtils.js';\nimport { importNode, isNode } from '../util/domUtils.js';\nimport { isElement } from '../internal/utils.js';\nconst createXmlDocument = () => {\n    return document.implementation.createDocument('', '', null);\n};\n/**\n * XML codec for JavaScript object graphs. See {@link ObjectCodec} for a\n * description of the general encoding/decoding scheme. This class uses the\n * codecs registered in {@link CodecRegistry} for encoding/decoding each object.\n *\n * ### References\n *\n * In order to resolve references, especially forward references, the Codec\n * constructor must be given the document that contains the referenced\n * elements.\n *\n * ### Examples\n *\n * The following code is used to encode a graph model.\n *\n * ```javascript\n * const encoder = new Codec();\n * const result = encoder.encode(graph.getDataModel());\n * const xml = xmlUtils.getXml(result);\n * ```\n *\n * **WARN**: as of version 0.6.0, the codecs provided by maxGraph are no longer registered by default, they **MUST** be registered before\n * performing `encode` or `decode`. For instance, you can use the {@link registerAllCodecs} function (or other related functions)\n * to register the codecs.\n *\n * #### Example\n *\n * Using the code below, an XML document is decoded into an existing model. The\n * document may be obtained using {@link parseXml} for parsing an XML string.\n *\n * ```javascript\n * const doc = xmlUtils.parseXml(xmlString);\n * const codec = new Codec(doc);\n * codec.decode(doc.documentElement, graph.getDataModel());\n * ```\n *\n * #### Example\n *\n * This example demonstrates parsing a list of isolated cells into an existing\n * graph model. Note that the cells do not have a parent reference so they can\n * be added anywhere in the cell hierarchy after parsing.\n *\n * ```javascript\n * const xml = `<GraphDataModel>\n *   <root>\n *     <Cell id=\"2\" value=\"Hello,\" vertex=\"1\">\n *       <Geometry _x=\"20\" _y=\"20\" _width=\"80\" _height=\"30\" as=\"geometry\"/>\n *     </Cell>\n *     <Cell id=\"3\" value=\"World!\" vertex=\"1\">\n *       <Geometry _x=\"200\" _y=\"150\" _width=\"80\" _height=\"30\" as=\"geometry\"/>\n *     </Cell>\n *     <Cell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\">\n *       <Geometry relative=\"1\" as=\"geometry\"/>\n *     </Cell>\n *   </root>\n * </GraphDataModel>\n * `;\n * const doc = xmlUtils.parseXml(xml);\n * const codec = new Codec(doc);\n * let elt = doc.documentElement.firstChild;\n * const cells = [];\n *\n * while (elt != null) {\n *   cells.push(codec.decode(elt));\n *   elt = elt.nextSibling;\n * }\n * graph.addCells(cells);\n * ```\n *\n * #### Example\n *\n * Using the following code, the selection cells of a graph are encoded and the\n * output is displayed in a dialog box.\n *\n * ```javascript\n * const enc = new Codec();\n * const cells = graph.getSelectionCells();\n * const xml = xmlUtils.getPrettyXml(enc.encode(cells));\n * ```\n *\n * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\n * must be passed to {@link getXml} as the second argument.\n *\n * ### Debugging\n *\n * For debugging, I/O you can use the following code to get the sequence of\n * encoded objects:\n *\n * ```javascript\n * const oldEncode = encode;\n * encode(obj)\n * {\n *   GlobalConfig.logger.show();\n *   GlobalConfig.logger.debug('Codec.encode: obj=' + StringUtils.getFunctionName(obj.constructor));\n *\n *   return oldEncode.apply(this, arguments);\n * };\n * ```\n *\n * Note that the I/O system adds object codecs for new object automatically. For\n * decoding those objects, the constructor should be written as follows:\n *\n * ```javascript\n * var MyObj(name)\n * {\n *   // ...\n * };\n * ```\n *\n * @category Serialization with Codecs\n */\nclass Codec {\n    constructor(document = createXmlDocument()) {\n        /**\n         * Lookup table for resolving IDs to elements.\n         */\n        this.elements = {};\n        /**\n         * Specifies if default values should be encoded.\n         * @default false\n         */\n        this.encodeDefaults = false;\n        this.document = document;\n        this.objects = {};\n    }\n    /**\n     * Associates the given object with the given ID and returns the given object.\n     *\n     * @param id ID for the object to be associated with.\n     * @param obj Object to be associated with the ID.\n     */\n    putObject(id, obj) {\n        this.objects[id] = obj;\n        return obj;\n    }\n    /**\n     * Returns the decoded object for the element with the specified ID in\n     * {@link document}. If the object is not known then {@link lookup} is used to find an\n     * object. If no object is found, then the element with the respective ID\n     * from the document is parsed using {@link decode}.\n     */\n    getObject(id) {\n        let obj = null;\n        if (id != null) {\n            obj = this.objects[id];\n            if (obj == null) {\n                obj = this.lookup(id);\n                if (obj == null) {\n                    const node = this.getElementById(id);\n                    if (node != null) {\n                        obj = this.decode(node);\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n    /**\n     * Hook for subclassers to implement a custom lookup mechanism for cell IDs.\n     * This implementation always returns null.\n     *\n     * Example:\n     *\n     * ```javascript\n     * const codec = new Codec();\n     * codec.lookup(id)\n     * {\n     *   return model.getCell(id);\n     * };\n     * ```\n     *\n     * @param id ID of the object to be returned.\n     */\n    lookup(id) {\n        return null;\n    }\n    /**\n     * Returns the element with the given ID from {@link document}.\n     *\n     * @param id String that contains the ID.\n     */\n    getElementById(id) {\n        this.updateElements();\n        return this.elements[id];\n    }\n    updateElements() {\n        if (Object.keys(this.elements).length === 0) {\n            if (this.document.documentElement != null) {\n                this.addElement(this.document.documentElement);\n            }\n        }\n    }\n    /**\n     * Adds the given element to {@link elements} if it has an ID.\n     */\n    addElement(node) {\n        if (isElement(node)) {\n            const id = node.getAttribute('id');\n            if (id != null) {\n                if (this.elements[id] == null) {\n                    this.elements[id] = node;\n                }\n                else if (this.elements[id] !== node) {\n                    throw new Error(`${id}: Duplicate ID`);\n                }\n            }\n        }\n        let nodeChild = node.firstChild;\n        while (nodeChild != null) {\n            this.addElement(nodeChild);\n            nodeChild = nodeChild.nextSibling;\n        }\n    }\n    /**\n     * Returns the ID of the specified object. This implementation\n     * calls {@link reference} first and if that returns null handles\n     * the object as an {@link Cell} by returning their IDs using\n     * {@link Cell.getId}. If no ID exists for the given cell, then\n     * an on-the-fly ID is generated using {@link CellPath.create}.\n     *\n     * @param obj Object to return the ID for.\n     */\n    getId(obj) {\n        let id = null;\n        if (obj != null) {\n            id = this.reference(obj);\n            if (id == null && obj instanceof Cell) {\n                id = obj.getId();\n                if (id == null) {\n                    // Uses an on-the-fly Id\n                    id = CellPath.create(obj);\n                    if (id.length === 0) {\n                        id = 'root';\n                    }\n                }\n            }\n        }\n        return id;\n    }\n    /**\n     * Hook for subclassers to implement a custom method\n     * for retrieving IDs from objects. This implementation\n     * always returns null.\n     *\n     * Example:\n     *\n     * ```javascript\n     * const codec = new Codec();\n     * codec.reference(obj)\n     * {\n     *   return obj.getCustomId();\n     * };\n     * ```\n     *\n     * @param obj Object whose ID should be returned.\n     */\n    reference(obj) {\n        return null;\n    }\n    /**\n     * Encodes the specified object and returns the resulting XML node.\n     *\n     * @param obj Object to be encoded.\n     */\n    encode(obj) {\n        let node = null;\n        if (obj != null && obj.constructor != null) {\n            const enc = CodecRegistry.getCodec(obj.constructor);\n            if (enc != null) {\n                node = enc.encode(this, obj);\n            }\n            else if (isNode(obj)) {\n                node = importNode(this.document, obj, true);\n            }\n            else {\n                GlobalConfig.logger.warn(`Codec.encode: No codec for ${getFunctionName(obj.constructor)}`);\n            }\n        }\n        return node;\n    }\n    /**\n     * Decodes the given XML node. The optional \"into\"\n     * argument specifies an existing object to be\n     * used. If no object is given, then a new instance\n     * is created using the constructor from the codec.\n     *\n     * The function returns the passed in object or\n     * the new instance if no object was given.\n     *\n     * @param node XML node to be decoded.\n     * @param into Optional object to be decoded into.\n     */\n    decode(node, into) {\n        this.updateElements();\n        let obj = null;\n        if (isElement(node)) {\n            const dec = CodecRegistry.getCodecByName(node.nodeName);\n            if (dec != null) {\n                obj = dec.decode(this, node, into);\n            }\n            else {\n                GlobalConfig.logger.warn(`Codec.decode: No codec found for node '${node.nodeName}', so the node won't be decoded, the original XML Element is returned instead.`);\n                obj = node.cloneNode(true);\n                obj.removeAttribute('as');\n            }\n        }\n        return obj;\n    }\n    /**\n     * Encoding of cell hierarchies is built-into the core, but\n     * is a higher-level function that needs to be explicitly\n     * used by the respective object encoders (e.g. {@link ModelCodec},\n     * {@link ChildChangeCodec} and {@link RootChangeCodec}). This\n     * implementation writes the given cell and its children as a\n     * (flat) sequence into the given node. The children are not\n     * encoded if the optional includeChildren is false. The\n     * function is in charge of adding the result into the\n     * given node and has no return value.\n     *\n     * @param cell {@link Cell} to be encoded.\n     * @param node Parent XML node to add the encoded cell into.\n     * @param includeChildren Optional boolean indicating if the\n     * function should include all descendents. Default is true.\n     */\n    encodeCell(cell, node, includeChildren) {\n        const appendMe = this.encode(cell);\n        if (appendMe) {\n            node.appendChild(appendMe);\n        }\n        if (includeChildren == null || includeChildren) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                this.encodeCell(cell.getChildAt(i), node);\n            }\n        }\n    }\n    /**\n     * Returns true if the given codec is a cell codec. This uses\n     * {@link CellCodec.isCellCodec} to check if the codec is of the\n     * given type.\n     */\n    isCellCodec(codec) {\n        if (codec && 'isCellCodec' in codec && typeof codec.isCellCodec === 'function') {\n            return codec.isCellCodec();\n        }\n        return false;\n    }\n    /**\n     * Decodes cells that have been encoded using inversion, ie.\n     * where the user object is the enclosing node in the XML,\n     * and restores the group and graph structure in the cells.\n     * Returns a new {@link Cell} instance that represents the\n     * given node.\n     *\n     * @param node XML node that contains the cell data.\n     * @param restoreStructures Optional boolean indicating whether\n     * the graph structure should be restored by calling insert\n     * and insertEdge on the parent and terminals, respectively.\n     * Default is `true`.\n     */\n    decodeCell(node, restoreStructures = true) {\n        if (!isElement(node)) {\n            return null;\n        }\n        // Tries to find a codec for the given node name. If that does\n        // not return a codec then the node is the user object (an XML node\n        // that contains the Cell, aka inversion).\n        let decoder = CodecRegistry.getCodec(node.nodeName);\n        // Tries to find the codec for the cell inside the user object.\n        // This assumes all node names inside the user object are either\n        // not registered or they correspond to a class for cells.\n        if (!this.isCellCodec(decoder)) {\n            let child = node.firstChild;\n            while (child != null && !this.isCellCodec(decoder)) {\n                decoder = CodecRegistry.getCodec(child.nodeName);\n                child = child.nextSibling;\n            }\n        }\n        if (!this.isCellCodec(decoder)) {\n            decoder = CodecRegistry.getCodec(Cell);\n        }\n        const cell = decoder?.decode(this, node);\n        if (restoreStructures) {\n            this.insertIntoGraph(cell);\n        }\n        return cell;\n    }\n    /**\n     * Inserts the given cell into its parent and terminal cells.\n     */\n    insertIntoGraph(cell) {\n        const { parent } = cell;\n        const source = cell.getTerminal(true);\n        const target = cell.getTerminal(false);\n        // Fixes possible inconsistencies during insert into graph\n        cell.setTerminal(null, false);\n        cell.setTerminal(null, true);\n        cell.parent = null;\n        if (parent != null) {\n            if (parent === cell) {\n                throw new Error(`${parent.id}: Self Reference`);\n            }\n            else {\n                parent.insert(cell);\n            }\n        }\n        if (source != null) {\n            source.insertEdge(cell, true);\n        }\n        if (target != null) {\n            target.insertEdge(cell, false);\n        }\n    }\n    /**\n     * Sets the attribute on the specified node to value. This is a\n     * helper method that makes sure the attribute and value arguments\n     * are not null.\n     *\n     * @param node XML node to set the attribute for.\n     * @param attribute The name of the attribute to be set.\n     * @param value New value of the attribute.\n     */\n    setAttribute(node, attribute, value) {\n        if (attribute != null && value != null) {\n            node.setAttribute(attribute, value);\n        }\n    }\n}\nexport default Codec;\n","/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CodecRegistry from '../CodecRegistry.js';\nimport ObjectCodec from '../ObjectCodec.js';\nimport Cell from '../../view/cell/Cell.js';\nimport { importNode } from '../../util/domUtils.js';\nimport { removeWhitespace } from '../../util/StringUtils.js';\nimport { isElement } from '../../internal/utils.js';\n/**\n * Codec for {@link Cell}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - children\n * - edges\n * - overlays\n * - mxTransient\n *\n * Reference Fields:\n *\n * - parent\n * - source\n * - target\n *\n * Transient fields can be added using the following code: `CodecRegistry.getCodec(Cell).exclude.push('name_of_field');`\n *\n * To subclass {@link Cell}, replace the template and add an alias as follows:\n *\n * ```javascript\n * // Given 'CustomCell' extends 'Cell'\n * CodecRegistry.getCodec(Cell).template = new CustomCell();\n * CodecRegistry.addAlias('CustomCell', 'Cell');\n * ```\n *\n * @category Serialization with Codecs\n */\nexport class CellCodec extends ObjectCodec {\n    constructor() {\n        super(new Cell(), ['children', 'edges', 'overlays', 'mxTransient'], ['parent', 'source', 'target']);\n        this.setName('Cell');\n    }\n    /**\n     * Returns `true` since this is a cell codec.\n     */\n    isCellCodec() {\n        return true;\n    }\n    /**\n     * Overridden to disable conversion of value to number.\n     */\n    isNumericAttribute(dec, attr, obj) {\n        return attr.nodeName !== 'value' && super.isNumericAttribute(dec, attr, obj);\n    }\n    /**\n     * Excludes user objects that are XML nodes.\n     */\n    isExcluded(obj, attr, value, isWrite) {\n        return (super.isExcluded(obj, attr, value, isWrite) ||\n            (isWrite && attr === 'value' && isElement(value)));\n    }\n    /**\n     * Encodes a {@link Cell} and wraps the XML up inside the XML of the user object (inversion).\n     */\n    afterEncode(enc, obj, node) {\n        if (isElement(obj.value)) {\n            // Wraps the graphical annotation up in the user object (inversion)\n            // by putting the result of the default encoding into a clone of the\n            // user object (node type 1) and returning this cloned user object.\n            const tmp = node;\n            node = importNode(enc.document, obj.value, true);\n            node.appendChild(tmp);\n            // Moves the id attribute to the outermost XML node, namely the\n            // node which denotes the object boundaries in the file.\n            const id = tmp.getAttribute('id');\n            node.setAttribute('id', String(id));\n            tmp.removeAttribute('id');\n        }\n        return node;\n    }\n    /**\n     * Decodes an {@link Cell} and uses the enclosing XML node as the user object for the cell (inversion).\n     */\n    beforeDecode(dec, node, obj) {\n        let inner = node.cloneNode(true);\n        const classname = this.getName();\n        if (node.nodeName !== classname) {\n            // Passes the inner graphical annotation node to the\n            // object codec for further processing of the cell.\n            const tmp = node.getElementsByTagName(classname)[0];\n            if (tmp != null && tmp.parentNode === node) {\n                removeWhitespace(tmp, true);\n                removeWhitespace(tmp, false);\n                tmp.parentNode.removeChild(tmp);\n                inner = tmp;\n            }\n            else {\n                inner = null;\n            }\n            // Creates the user object out of the XML node\n            obj.value = node.cloneNode(true);\n            const id = obj.value.getAttribute('id');\n            if (id != null) {\n                obj.setId(id);\n                obj.value.removeAttribute('id');\n            }\n        }\n        else {\n            // Uses ID from XML file as ID for cell in model\n            obj.setId(node.getAttribute('id'));\n        }\n        // Preprocesses and removes all Id-references in order to use the\n        // correct encoder (this) for the known references to cells (all).\n        if (inner != null) {\n            for (let i = 0; i < this.idrefs.length; i += 1) {\n                const attr = this.idrefs[i];\n                const ref = inner.getAttribute(attr);\n                if (ref != null) {\n                    inner.removeAttribute(attr);\n                    let object = dec.objects[ref] || dec.lookup(ref);\n                    if (object == null) {\n                        // Needs to decode forward reference\n                        const element = dec.getElementById(ref);\n                        if (element != null) {\n                            const decoder = CodecRegistry.codecs[element.nodeName] || this;\n                            object = decoder.decode(dec, element);\n                        }\n                    }\n                    // @ts-ignore dynamic assignment was in original implementation\n                    obj[attr] = object;\n                }\n            }\n        }\n        return inner;\n    }\n}\n","/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec.js';\nimport GraphDataModel from '../../view/GraphDataModel.js';\n/**\n * Codec for {@link GraphDataModel}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * @category Serialization with Codecs\n */\nexport class ModelCodec extends ObjectCodec {\n    constructor() {\n        super(new GraphDataModel());\n        this.setName('GraphDataModel');\n    }\n    /**\n     * Encodes the given {@link GraphDataModel} by writing a (flat) XML sequence of cell nodes as produced by the {@link CellCodec}.\n     * The sequence is wrapped-up in a node with the name `root`.\n     */\n    encodeObject(enc, obj, node) {\n        const rootNode = enc.document.createElement('root');\n        enc.encodeCell(obj.getRoot(), rootNode);\n        node.appendChild(rootNode);\n    }\n    /**\n     * Overrides decode child to handle special child nodes.\n     */\n    decodeChild(dec, child, obj) {\n        if (child.nodeName === 'root') {\n            this.decodeRoot(dec, child, obj);\n        }\n        else {\n            super.decodeChild(dec, child, obj);\n        }\n    }\n    /**\n     * Reads the cells into the graph model. All cells are children of the root element in the node.\n     */\n    decodeRoot(dec, root, model) {\n        let rootCell = null;\n        let tmp = root.firstChild;\n        while (tmp != null) {\n            const cell = dec.decodeCell(tmp);\n            if (cell != null && cell.getParent() == null) {\n                rootCell = cell;\n            }\n            tmp = tmp.nextSibling;\n        }\n        // Sets the root on the model if one has been decoded\n        if (rootCell != null) {\n            model.setRoot(rootCell);\n        }\n    }\n}\n","/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isNumeric } from '../../../util/mathUtils.js';\n// from mxGraph to maxGraph\nconst fieldMapping = new Map([['autosize', 'autoSize']]);\nexport function convertStyleFromString(input) {\n    const style = {};\n    input.startsWith(';') && (style.ignoreDefaultStyle = true);\n    const elements = input\n        .split(';')\n        // filter empty key\n        .filter(([k]) => k);\n    for (const element of elements) {\n        if (!element.includes('=')) {\n            !style.baseStyleNames && (style.baseStyleNames = []);\n            style.baseStyleNames.push(element);\n        }\n        else {\n            const [key, value] = element.split('=');\n            // @ts-ignore\n            style[fieldMapping.get(key) ?? key] = convertToNumericIfNeeded(value);\n        }\n    }\n    return style;\n}\nfunction convertToNumericIfNeeded(value) {\n    // Adapted from ObjectCodec.convertAttributeFromXml\n    if (!isNumeric(value)) {\n        return value;\n    }\n    let numericValue = parseFloat(value);\n    if (Number.isNaN(numericValue) || !Number.isFinite(numericValue)) {\n        numericValue = 0;\n    }\n    return numericValue;\n}\n","/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { convertStyleFromString } from './utils.js';\nimport { CellCodec } from '../CellCodec.js';\n/**\n * Add support for the legacy `mxGraph` format of {@link Cell}.\n *\n * @category Serialization with Codecs\n */\nexport class mxCellCodec extends CellCodec {\n    getName() {\n        return 'mxCell';\n    }\n    decodeAttribute(dec, attr, obj) {\n        const attributeNodeName = attr.nodeName;\n        if (obj && attributeNodeName == 'style') {\n            obj['style'] = convertStyleFromString(attr.value);\n        }\n        else {\n            super.decodeAttribute(dec, attr, obj);\n        }\n    }\n}\n","/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../../ObjectCodec.js';\nimport Geometry from '../../../view/geometry/Geometry.js';\nimport Point from '../../../view/geometry/Point.js';\n/**\n * Add support for the legacy `mxGraph` format of {@link Geometry}.\n *\n * @category Serialization with Codecs\n */\nexport class mxGeometryCodec extends ObjectCodec {\n    getName() {\n        return 'mxGeometry';\n    }\n    constructor() {\n        super(new Geometry());\n    }\n    afterDecode(dec, node, obj) {\n        // Convert points to the right form\n        // input: [ { x: 420, y: 60 }, ... ]\n        // output: [ Point { _x: 420, _y: 60 }, ... ]\n        //\n        // In mxGraph XML, the points are modeled as Object, so there is no way to create an alias to do the decoding with a custom Codec.\n        // Then, it is easier to convert the values to Point objects after the whole decoding of the geometry\n        // <Array as=\"points\">\n        //   <Object x=\"420\" y=\"60\"/>\n        // </Array>\n        const originalPoints = obj.points;\n        if (originalPoints) {\n            const points = [];\n            for (const pointInput of originalPoints) {\n                const rawPoint = pointInput;\n                points.push(new Point(rawPoint.x, rawPoint.y));\n            }\n            obj.points = points;\n        }\n        return obj;\n    }\n}\n","/*\nCopyright 2025-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// The elements in this file are private and are not intended to be exported by the npm package\nimport CodecRegistry from './CodecRegistry.js';\nimport ObjectCodec from './ObjectCodec.js';\n/**\n * @private\n */\nexport const CodecRegistrationStates = {\n    base: false,\n    core: false,\n    editor: false,\n    model: false,\n};\n/**\n * @private\n */\nexport const registerBaseCodecs = (force = false) => {\n    if (!CodecRegistrationStates.base || force) {\n        CodecRegistry.register(createObjectCodec({}, 'Object'));\n        CodecRegistry.register(createObjectCodec([], 'Array'));\n        CodecRegistrationStates.base = true;\n    }\n};\nexport const createObjectCodec = (template, name) => {\n    const objectCodec = new ObjectCodec(template);\n    objectCodec.setName(name);\n    return objectCodec;\n};\n","/*\nCopyright 2025-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CodecRegistry from './CodecRegistry.js';\nimport { CellCodec, ModelCodec, mxCellCodec, mxGeometryCodec, } from './codecs/_model-codecs.js';\nimport Geometry from '../view/geometry/Geometry.js';\nimport Point from '../view/geometry/Point.js';\nimport { CodecRegistrationStates, createObjectCodec, registerBaseCodecs, } from './register-shared.js';\n/**\n * Register model codecs i.e. codecs used to import/export the Graph Model, see {@link GraphDataModel}.\n *\n * @param force if `true` register the codecs even if they were already registered. If false, only register them\n *              if they have never been registered before.\n * @since 0.10.0\n * @category Configuration\n * @category Serialization with Codecs\n */\nexport const registerModelCodecs = (force = false) => {\n    if (!CodecRegistrationStates.model || force) {\n        CodecRegistry.register(new CellCodec());\n        CodecRegistry.register(new ModelCodec());\n        // To support decode/import executed before encode/export (see https://github.com/maxGraph/maxGraph/issues/178)\n        // Codecs are currently only registered automatically during encode/export\n        CodecRegistry.register(createObjectCodec(new Geometry(), 'Geometry'));\n        CodecRegistry.register(createObjectCodec(new Point(), 'Point'));\n        registerBaseCodecs(force);\n        // mxGraph support\n        CodecRegistry.addAlias('mxGraphModel', 'GraphDataModel');\n        CodecRegistry.addAlias('mxPoint', 'Point');\n        CodecRegistry.register(new mxCellCodec(), false);\n        CodecRegistry.register(new mxGeometryCodec(), false);\n        CodecRegistrationStates.model = true;\n    }\n};\n","/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { registerModelCodecs } from './register-model-codecs.js';\nimport { getPrettyXml, getXml, parseXml } from '../util/xmlUtils.js';\nimport Codec from './Codec.js';\n/**\n * Convenient utility class using {@link Codec} to manage maxGraph model import and export.\n *\n * **WARN**: this is an experimental feature that is subject to change (class and method names).\n *\n * @experimental\n * @since 0.6.0\n * @category Serialization with Codecs\n */\n// Include 'XML' in the class name as there were past discussions about supporting other format like JSON for example\n// See https://github.com/maxGraph/maxGraph/discussions/60 for more details.\nexport class ModelXmlSerializer {\n    constructor(dataModel) {\n        this.dataModel = dataModel;\n        this.registerCodecs();\n    }\n    import(input) {\n        const doc = typeof input === 'string' ? parseXml(input) : input.ownerDocument;\n        new Codec(doc).decode(doc.documentElement, this.dataModel);\n    }\n    export(options) {\n        const encodedNode = new Codec().encode(this.dataModel);\n        return (options?.pretty ?? true) ? getPrettyXml(encodedNode) : getXml(encodedNode);\n    }\n    /**\n     * Hook for replacing codecs registered by default (model codecs).\n     */\n    registerCodecs() {\n        registerModelCodecs();\n    }\n}\n","// src/bpmn-save.ts\nimport { AbstractGraph, ModelXmlSerializer } from '@maxgraph/core';\nimport { getCurrentBpmnData, BpmnData } from './bpmn-load';\nimport { showStatus } from './bpmn-edit';\n\n// Expose helpers globaux comme avant\ndeclare global {\n    interface Window {\n        loadGraph?: (xml: string) => void;\n        getXMLGraph?: () => string;\n    }\n}\n\n// Import dun XML MaxGraph dans le modle\nexport function loadGraphXml(graph: AbstractGraph, xml: string) {\n    new ModelXmlSerializer(graph.model).import(xml);\n}\n\n// Gnrer le XML BPMN mis  jour (positions)\nexport function getXMLGraph(graph: AbstractGraph) {\n\n    console.log(' Gnration du XML BPMN mis  jour');\n\n    const xml = new ModelXmlSerializer(graph.model).export();\n\n    console.log(' XML BPMN gnr');\n    return xml;\n}\n\nexport async function saveGraphToDatabase(\n    id: number,\n    name: string,\n    type: string,\n    content: string\n): Promise<void> {\n    console.log('saveGraphToDatabase:', id, 'name:', name);\n\n    try {\n        const response = await fetch(`/admin/bpmn/${id}`, {\n            method: 'POST', // on poste...\n            credentials: 'same-origin',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'X-CSRF-TOKEN': window.document\n                    .querySelector('meta[name=\"csrf-token\"]')\n                    ?.getAttribute('content') ?? '',\n                'X-Requested-With': 'XMLHttpRequest',\n            },\n            body: JSON.stringify({\n                _method: 'PUT',\n                id,\n                name,\n                type,\n                content,\n            }),\n        });\n\n        console.log('rponse :', response.status);\n        if (response.status !== 200) {\n            let errorMsg = 'Erreur lors de la sauvegarde du graphe.';\n            try {\n                const error = await response.json();\n                errorMsg = error.message || errorMsg;\n            } catch (_) {\n                // ignore JSON parse error\n            }\n            throw new Error(errorMsg);\n        }\n\n        showStatus(' Graphe sauvegard', 2000);\n    } catch (error) {\n        console.error('Erreur lors de la sauvegarde :', error);\n        alert('Erreur lors de la sauvegarde du graphe.');\n    }\n}\n\n// Cbler le bouton \"save\"\nexport function bindSaveButton(graph: AbstractGraph, buttonId = 'save-btn') {\n    const btn = document.getElementById(buttonId);\n    if (!btn) {\n        console.warn(`#${buttonId} introuvable, bouton de sauvegarde non cbl`);\n        return;\n    }\n\n    btn.addEventListener('click', () => {\n        const id = Number((window.document.querySelector('#id') as HTMLInputElement | null)?.value);\n        const name = (window.document.querySelector('#name') as HTMLInputElement | null)?.value ?? '';\n        const type = (window.document.querySelector('#type') as HTMLInputElement | null)?.value ?? '';\n\n        const xml = getXMLGraph(graph);\n        if (!xml) {\n            showStatus(' Impossible de gnrer le BPMN', 3000);\n            return;\n        }\n\n        saveGraphToDatabase(id, name, type, xml).then(() =>\n            console.log('Graphe sauvegard avec succs')\n        );\n    });\n\n    console.log(' Bouton de sauvegarde cbl');\n}\n\n// Exposer les helpers sur window (comme avant)\nexport function exposeGraphHelpers(graph: AbstractGraph) {\n    window.loadGraph = (xml: string) => loadGraphXml(graph, xml);\n    window.getXMLGraph = () => getXMLGraph(graph);\n}\n"],"names":["MaxXmlRequest","url","params","method","async","username","password","value","doc","xml","req","onload","onerror","timeout","ontimeout","request","target","old","form","pars","i","pos","name","textarea","write","load","geometryNumericAttributes","pointNumericAttributes","ObjectCodec","template","exclude","idrefs","mapping","attributename","mapped","fieldname","obj","attr","ObjectIdentity","enc","node","isInteger","tmp","GlobalConfig","child","dec","Geometry","Point","isNumeric","into","id","_node","attrs","isElement","doEval","getTextContent","e","CodecRegistry","codec","registerAlias","classname","className","codecName","constructorOrName","alias","createXmlDocument","Codec","document","nodeChild","Cell","CellPath","isNode","importNode","getFunctionName","cell","includeChildren","appendMe","childCount","restoreStructures","decoder","parent","source","attribute","CellCodec","isWrite","inner","removeWhitespace","ref","object","element","ModelCodec","GraphDataModel","rootNode","root","model","rootCell","fieldMapping","convertStyleFromString","input","style","elements","k","key","convertToNumericIfNeeded","numericValue","mxCellCodec","attributeNodeName","mxGeometryCodec","originalPoints","points","pointInput","rawPoint","CodecRegistrationStates","registerBaseCodecs","force","createObjectCodec","objectCodec","registerModelCodecs","ModelXmlSerializer","dataModel","parseXml","options","encodedNode","getPrettyXml","getXml","loadGraphXml","graph","getXMLGraph","saveGraphToDatabase","type","content","response","errorMsg","showStatus","error","bindSaveButton","buttonId","btn","exposeGraphHelpers"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}